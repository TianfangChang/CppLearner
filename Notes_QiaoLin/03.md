## 算法 

**算法设计与实现**

​	构造算法解决问题

​	按照自顶向下、逐步求精的方式进行

​	使用程序设计语言编程实现

**算法选择权衡指标**

- 正确性
- **效率**
- 可理解性

**递归算法**

​	逐步分解问题，使其简单化

​	回归过程：组装成最后的答案

**算法复杂度**

$O(1)$ 常数，执行时间与规模无关

$O(\log{(n)})$ 对数

$O(\sqrt{(n)})$ 平方根

$O(n)$ 与问题规模成正比

$O(n*\log{(n)})$ 

$O(n^2)$ 平方

循环嵌套次数：一次循环$O(n)$，两次循环$O(n^2)$

## 库与程序文件

源文件 \*.cpp

头文 件 \*.h \*.hpp

#### linux的数学库

头文件： math.h / cmath

库文件： libm

链接方式：`g++ -lm main.cpp`

#### 工具与辅助函数

头文件：stdlib.h / cstdlib

**常用函数**

 ```c++
 void exit(int status);	//退出程序
 void free(void *p);		//动态内存分配
 void *malloc(size_t size);	//动态内存分配    
 int rand();    //随机数
 void srand(unsigned int seed);	//随机数
 ```

**作用域**

不要在头文件中定义全局数据对象 

访问全局变量：`::i`

### 生存期

量在程序中存在的时间范围

C/C++存储类表示生存期

作用域表达量的空间特性，存储类表达量的时间特性

**静态（全局）生存期**

全局数据对象具有静态（全局）生存期

生死仅与程序是否执行有关

**自动（局部）生存期**

生死仅与程序流程是否位于该块中有关

进入时产生，退出时死亡

如重复调用，不是同一变量

### static

##### 修饰局部变量：静态局部变量

- 使局部变量具有静态生存期
- 程序退出该块时局部变量仍然存在，并在下次进入该块时使用上一次的数据值
- 静态局部变量必须进行初始化
- 不改变量的作用域，仍具有块作用域，即只能在该块中访问，其他代码段不可见

##### 修饰全局变量

- 使其作用域仅限定于本文件内部，其他文件不可见 

##### 函数具有文件作用域与静态生存期

- 程序每次执行时都存在，并且可以在函数原型或函数定义后的任意位置调用

##### 内部函数与外部函数

- 外部函数：可以被其他文件中的函数所调用
- 内部函数：不可以被其他文件中的函数所调用
- 内部函数定义：使用static关键字
- 内部函数示例：`static int Transform(int x);`
- 不能写在头文件

##### 声命与定义

- 定义程序产生一个新实体
- 声明仅仅在程序中引入一个实体

##### 函数的声明与定义

- 声明是给出函数原型，定义是给出函数实现代码

##### 类型的声明与定义

- 产生新的类型就是定义

  类型定义示例：`typedef enum __BOOL {FALSE, TRUE} BOOL;`

- 不产生新类型就不是定义，而仅仅是声明

  类型声明示例：`enum __BOOL;`

**全局变量的定义不能出现在头文件，只有声明可以**

声明格式：extern `extern int a`

# 不要在头文件定义全局变量

